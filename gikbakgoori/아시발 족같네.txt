com.example.boot.exchange/
├── core/                           # Layer 1
│   ├── protocol/
│   │   ├── ExchangeProtocol.java
│   │   ├── BinanceProtocol.java
│   │   ├── UpbitProtocol.java
│   │   └── BithumbProtocol.java
│   └── model/
│       ├── CurrencyPair.java
│       ├── ExchangeMessage.java
│       └── NormalizedMessage.java
│
├── websocket/                      # Layer 2
│   ├── WebSocketConnector.java
│   ├── ReactiveWebSocketConnector.java
│   ├── SessionManager.java
│   └── config/
│       └── WebSocketConfig.java
│
├── message/                        # Layer 3
│   ├── MessageHandler.java
│   ├── ExchangeMessageHandler.java
│   ├── MessageTransformer.java
│   └── MessageValidator.java
│
├── subscription/                   # Layer 4
│   ├── SubscriptionManager.java
│   ├── SubscriptionStore.java
│   └── validator/
│       └── SubscriptionValidator.java
│
└── infrastructure/                 # 외부 통합
    ├── kafka/
    │   ├── config/
    │   │   ├── KafkaConsumerConfig.java
    │   │   └── KafkaProducerConfig.java
    │   └── publisher/
    │       └── KafkaMessagePublisher.java
    └── client/
        ├── ClientWebSocketHandler.java
        └── ClientSessionManager.java




# Exchange Service 아키텍처 설계

## 핵심 레이어 구조

### Layer 1: Core Domain
위치: com.example.boot.exchange.core
- 가장 핵심적인 비즈니스 로직
- 외부 의존성이 전혀 없는 순수한 도메인 로직

구성:
/protocol
  - ExchangeProtocol (interface)
  - BinanceProtocol
  - UpbitProtocol
  - BithumbProtocol
/model
  - CurrencyPair
  - NormalizedMessage
  - ExchangeMessage

주요 변경사항:
- 모든 외부 의존성 제거
- 순수 도메인 모델과 프로토콜 정의
- Immutable 객체 사용

### Layer 2: WebSocket Connection
위치: com.example.boot.exchange.websocket
- 거래소 웹소켓 연결 관리
- Reactive Streams 기반 비동기 처리

구성:
- WebSocketConnector (interface)
- ReactiveWebSocketConnector
- SessionManager
- ConnectionConfig

주요 변경사항:
- Flux 기반 스트림 처리 구현




### Layer 3: Message Handler
위치: com.example.boot.exchange.message
- 메시지 정규화와 변환
- Reactive 스트림 처리

구성:
- MessageHandler (interface)
- ExchangeMessageHandler
- MessageTransformer
- MessageValidator

주요 변경사항:
- Reactive 스트림 처리 적용



### Layer 4: Subscription
위치: com.example.boot.exchange.subscription
- 구독 관리 및 상태 관리
- Reactive 기반 구독 처리

구성:
- SubscriptionManager
- SubscriptionStore
- SubscriptionValidator

주요 변경사항:
- Reactive 구독 관리



## 외부 통합 계층 (Infrastructure)

### Kafka Integration
위치: com.example.boot.infrastructure.kafka
- 핵심 레이어들을 사용하는 카프카 구현
- 핵심 레이어에 대한 의존성만 있음

구성:
- KafkaMessagePublisher
- KafkaConsumerConfig
- KafkaProducerConfig
- LeaderElection (선택적)

### Client Integration
위치: com.example.boot.infrastructure.client
- 핵심 레이어들을 사용하는 클라이언트 구현
- 핵심 레이어에 대한 의존성만 있음

구성:
- ClientWebSocketHandler
- ClientSessionManager
- WebSocketConfig

## 주요 설계 원칙

1. Reactive 프로그래밍
- 모든 비동기 작업은 Reactor의 Flux/Mono 사용
- 블로킹 작업 최소화
- 백프레셔 지원

2. 의존성 방향
- 핵심 레이어(1-4)는 외부 의존성이 없음
- 카프카와 클라이언트는 핵심 레이어를 사용
- 상위 레이어는 하위 레이어에만 의존

3. 확장성
- 새로운 거래소 추가가 용이한 구조
- 메시지 처리 파이프라인의 유연한 확장
- 구독 관리의 독립적 확장

4. 테스트 용이성
- 각 레이어별 독립적인 테스트 가능
- 외부 의존성에 대한 모킹 최소화
- Reactive 스트림 테스트 지원


이렇게 구성하면:
핵심 레이어들이 완전히 독립적
카프카와 클라이언트는 단순히 이 레이어들을 사용하는 구현체
Reactive 스트림으로 일관된 비동기 처리
테스트와 유지보수가 용이
이런 방향으로 진행하는 것이 어떠신가요?